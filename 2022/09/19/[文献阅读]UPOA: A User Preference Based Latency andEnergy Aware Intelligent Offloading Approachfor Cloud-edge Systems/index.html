<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本文考虑了基于低电池焦虑导致的用户偏好的影响，提出了UPOA算法，以根据用户偏好在低延迟和能耗之间获得精确的卸载策略。">
<meta property="og:type" content="article">
<meta property="og:title" content="[文献阅读]UPOA: A User Preference Based Latency andEnergy Aware Intelligent Offloading Approachfor Cloud-edge Systems UPOA：一种基于用户偏好的延迟和能量感知的云边缘系统智能卸载方法">
<meta property="og:url" content="http://example.com/2022/09/19/[%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB]UPOA:%20A%20User%20Preference%20Based%20Latency%20andEnergy%20Aware%20Intelligent%20Offloading%20Approachfor%20Cloud-edge%20Systems/index.html">
<meta property="og:site_name" content="生灵">
<meta property="og:description" content="本文考虑了基于低电池焦虑导致的用户偏好的影响，提出了UPOA算法，以根据用户偏好在低延迟和能耗之间获得精确的卸载策略。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-09-19T07:42:43.000Z">
<meta property="article:modified_time" content="2022-09-22T06:00:10.816Z">
<meta property="article:author" content="Ciallo～(∠・ω&lt; )⌒☆​">
<meta property="article:tag" content="文献阅读">
<meta property="article:tag" content="边缘计算">
<meta property="article:tag" content="计算卸载">
<meta property="article:tag" content="深度学习">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2022/09/19/[%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB]UPOA:%20A%20User%20Preference%20Based%20Latency%20andEnergy%20Aware%20Intelligent%20Offloading%20Approachfor%20Cloud-edge%20Systems/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/09/19/[%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB]UPOA:%20A%20User%20Preference%20Based%20Latency%20andEnergy%20Aware%20Intelligent%20Offloading%20Approachfor%20Cloud-edge%20Systems/","path":"2022/09/19/[文献阅读]UPOA: A User Preference Based Latency andEnergy Aware Intelligent Offloading Approachfor Cloud-edge Systems/","title":"[文献阅读]UPOA: A User Preference Based Latency andEnergy Aware Intelligent Offloading Approachfor Cloud-edge Systems UPOA：一种基于用户偏好的延迟和能量感知的云边缘系统智能卸载方法"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>[文献阅读]UPOA: A User Preference Based Latency andEnergy Aware Intelligent Offloading Approachfor Cloud-edge Systems UPOA：一种基于用户偏好的延迟和能量感知的云边缘系统智能卸载方法 | 生灵</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">生灵</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>目录</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%91%98%E8%A6%81%E5%8F%8A%E5%85%B6%E8%B4%A1%E7%8C%AE"><span class="nav-number">1.</span> <span class="nav-text">摘要及其贡献</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">系统模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%81%8F%E5%A5%BD%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.</span> <span class="nav-text">用户偏好的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%B8%E8%BD%BD%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">卸载模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E5%BB%B6%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.2.1.</span> <span class="nav-text">时延模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%BD%E8%80%97%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.2.2.</span> <span class="nav-text">能耗模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%A2%84%E6%B5%8B%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">任务预测算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%B8%E8%BD%BD%E7%AE%97%E6%B3%95"><span class="nav-number">2.4.</span> <span class="nav-text">卸载算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.1.</span> <span class="nav-text">优化问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%B8%E8%BD%BD%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.4.2.</span> <span class="nav-text">卸载算法设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.4.3.</span> <span class="nav-text">加法运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.4.4.</span> <span class="nav-text">减法运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%BC%82%E7%AE%97%E5%AD%90"><span class="nav-number">2.4.5.</span> <span class="nav-text">变异算子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-number">2.4.6.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.4.7.</span> <span class="nav-text">算法步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%A8%A1%E6%8B%9F"><span class="nav-number">3.</span> <span class="nav-text">实验模拟</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83"><span class="nav-number">3.1.</span> <span class="nav-text">实验环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">对比算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E7%BB%93%E6%9E%9C"><span class="nav-number">3.2.1.</span> <span class="nav-text">模拟结果</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BA%E6%96%87%E5%9C%B0%E5%9D%80"><span class="nav-number">4.</span> <span class="nav-text">论文地址</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ciallo～(∠・ω< )⌒☆​"
      src="/images/dh.png">
  <p class="site-author-name" itemprop="name">Ciallo～(∠・ω< )⌒☆​</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">目录</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/19/[%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB]UPOA:%20A%20User%20Preference%20Based%20Latency%20andEnergy%20Aware%20Intelligent%20Offloading%20Approachfor%20Cloud-edge%20Systems/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/dh.png">
      <meta itemprop="name" content="Ciallo～(∠・ω< )⌒☆​">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="生灵">
      <meta itemprop="description" content="">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="[文献阅读]UPOA: A User Preference Based Latency andEnergy Aware Intelligent Offloading Approachfor Cloud-edge Systems UPOA：一种基于用户偏好的延迟和能量感知的云边缘系统智能卸载方法 | 生灵">
      <meta itemprop="description" content="本文考虑了基于低电池焦虑导致的用户偏好的影响，提出了UPOA算法，以根据用户偏好在低延迟和能耗之间获得精确的卸载策略。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          [文献阅读]UPOA: A User Preference Based Latency andEnergy Aware Intelligent Offloading Approachfor Cloud-edge Systems UPOA：一种基于用户偏好的延迟和能量感知的云边缘系统智能卸载方法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-19 15:42:43" itemprop="dateCreated datePublished" datetime="2022-09-19T15:42:43+08:00">2022-09-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-22 14:00:10" itemprop="dateModified" datetime="2022-09-22T14:00:10+08:00">2022-09-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">收录于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">文献阅读</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">本文考虑了基于低电池焦虑导致的用户偏好的影响，提出了UPOA算法，以根据用户偏好在低延迟和能耗之间获得精确的卸载策略。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="摘要及其贡献"><a href="#摘要及其贡献" class="headerlink" title="摘要及其贡献"></a>摘要及其贡献</h1><ul>
<li>期刊： IEEE Transactions on Cloud Computing.sci-Q2，CCF-C.2022.</li>
<li>简称：IMD（互联网移动设备），EN（边缘节点），CD（云数据中心）</li>
<li>贡献：</li>
<li>可以根据用户偏好来动态调整卸载策略。如用时延换能耗，用能耗换时延。</li>
</ul>
<hr>
<h1 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h1><p><strong>用户可以在本地运算，在边缘服务器上运算，在云服务器上运算。</strong></p>
<h2 id="用户偏好的定义"><a href="#用户偏好的定义" class="headerlink" title="用户偏好的定义"></a>用户偏好的定义</h2><ul>
<li><p>定义公式：$U \equiv  \lim_{T \to \infty } \frac{1}{T} \sum^T_{t=0}E(\alpha T_{total}(t) + \beta P_{total} (t))$ .</p>
<blockquote>
<p> $T_{total}(t)$表示时隙内的时延，$P_{total} (t)$表示时隙内的能耗。$\alpha,\beta$为权重，$\alpha + \beta = 1$。</p>
</blockquote>
</li>
<li><p>用户的偏好规则：</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">{</mo><mtable columnalign="left" columnspacing="1em" rowspacing="4pt"><mtr><mtd><mi>α</mi><mo>&gt;</mo><mi>β</mi><mo>,</mo><msub><mi>Soc</mi><mrow><mi>i</mi></mrow></msub><mo data-mjx-texclass="NONE">⁡</mo><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>&gt;</mo><msup><mi>Soc</mi><mrow><mi>U</mi><mi>p</mi></mrow></msup><mo data-mjx-texclass="NONE">⁡</mo><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mtd></mtr><mtr><mtd><mi>α</mi><mo>=</mo><mi>β</mi><mo>,</mo><msup><mi>Soc</mi><mrow><mi>D</mi><mi>o</mi><mi>w</mi><mi>n</mi></mrow></msup><mo data-mjx-texclass="NONE">⁡</mo><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>&lt;</mo><msub><mi>Soc</mi><mrow><mi>i</mi></mrow></msub><mo data-mjx-texclass="NONE">⁡</mo><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>≤</mo><msup><mi>Soc</mi><mrow><mi>U</mi><mi>p</mi></mrow></msup><mo data-mjx-texclass="NONE">⁡</mo><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mtd></mtr><mtr><mtd><mi>α</mi><mo>&lt;</mo><mi>β</mi><mo>,</mo><msub><mi>Soc</mi><mrow><mi>i</mi></mrow></msub><mo data-mjx-texclass="NONE">⁡</mo><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>≤</mo><msup><mi>Soc</mi><mrow><mtext>Down&nbsp;</mtext></mrow></msup><mo data-mjx-texclass="NONE">⁡</mo><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE" fence="true" stretchy="true" symmetric="true"></mo></mrow></math>

<blockquote>
<p>$Soc^{U p}(t)$表示电池能量状态上限，$ \operatorname{Soc}^{D o w n}(t)$表示电池能量状态下限，低于此标准，用户的将偏向节能。</p>
</blockquote>
</li>
<li><p>eg.</p>
</li>
<li>电量&gt;$\operatorname{Soc}^{U p}(t)$，则偏向减少时延。</li>
<li><p>电量&lt;$\operatorname{Soc}^{D o w n}(t)$，则偏向减少能耗。<br>文中提出了三种偏好规则方案。如下图所示：<br><img src = "
/UPOA/
图片1.png
" height = 400></p>
</li>
<li><p>高敏感方案：$\operatorname{Soc}^{U p}(t)$:50%, $\operatorname{Soc}^{D o w n}(t)$:50%.每当电池减少1%，$\alpha$和$\beta$的值都以0.1的步长进行调整。</p>
</li>
<li>中等敏感方案：$\operatorname{Soc}^{U p}(t)$:65%, $\operatorname{Soc}^{D o w n}(t)$:35%.设计了六个能量状态区间来调整α和β的值，以平衡能量消耗和延迟。仅当出现电池电量不足警告信息时，低能耗敏感用户才会注意节能。</li>
<li>低敏感方案：$\operatorname{Soc}^{U p}(t)$:80%, $\operatorname{Soc}^{D o w n}(t)$:20%.当能量状态小于20%时，β值分别增加到0.75（能量状态为[20%，10%）和0.85（能量状况为[10%，0%]）。</li>
</ul>
<h2 id="卸载模型"><a href="#卸载模型" class="headerlink" title="卸载模型"></a>卸载模型</h2><p>文中提出了五个子模型来表征每个节点在其卸载链路中的任务分配。<br><img src = "
/UPOA/
图片2.png
" height = 400></p>
<ul>
<li>预测记录队列(PRQ)：用于预测未来时间窗口内到达的任务数量。每个时隙中，当实际任务到达时，是一任务将替换预测记录队列，为预测算法提供优化反馈。</li>
<li>任务积压队列(TBQ)：用于存储等待处理的实时任务。在每个时隙中，TBQ将存储的任分配到本地队列或卸载队列进行处理。</li>
<li>本地积压队列(LBQ)：用于存储等待CPU处理的任务。在每个时隙中，LBQ将这些任务发送到CPU进行处理。</li>
<li><p>卸载积压队列(OBQ)：用于存储等待卸载的任务。在每个时隙中，OBQ将这些任务卸载到其卸载目标。任务的传输速率由用户决定。</p>
<blockquote>
<p>因为边缘节点中的任务来自于用户，所以边缘节点不需要PRQ。</p>
</blockquote>
</li>
</ul>
<h3 id="时延模型"><a href="#时延模型" class="headerlink" title="时延模型"></a>时延模型</h3><ul>
<li><p>根据little’s 定律，用户的平均等待时间为：$T^i_{av}(t) = \frac{B^i_{imd,q}(t)}{\lambda_i}$</p>
<blockquote>
<ul>
<li>$\lambda_i = \mathbb{E}(X_i(t))$,$X_i(t)$为用户i在时隙t内生成的任务。$B^i_{imd,q}(t)$为时隙t内TBQ内的平均任务数量。</li>
<li>Little’s 定律：在一个稳定的系统中，长期的平均顾客人数（L），等于长期的有效抵达率（λ），乘以顾客在这个系统中平均的等待时间（W）；或者，我们可以用一个代数式来表达：$L=λW$.</li>
</ul>
</blockquote>
</li>
<li><p>TBQ可以根据PRQ的预测来提前分发任务。设时隙t和时隙t+k内产生的任务为：$O^i_k(t)$，有：$\sum_{k=0}^K O^i_k(t) = B^i_{imd,q}(t) + B^i_{imd,o}(t)$。</p>
</li>
<li><p>传输速率：</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true" columnalign="right left right left right left right left right left right left" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" rowspacing="3pt"><mtr><mtd><msubsup><mi>T</mi><mrow><mtext>tran&nbsp;</mtext></mrow><mrow><mi>i</mi></mrow></msubsup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mtd><mtd><mi></mi><mo>=</mo><mi>ϖ</mi><msub><mi>log</mi><mrow><mn>2</mn></mrow></msub><mo data-mjx-texclass="NONE">⁡</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>tran</mi><mo>,</mo><mi>i</mi></mrow></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><msub><mi>s</mi><mrow><mi>i</mi></mrow></msub></mrow><mrow><mi>V</mi><msub><mi>W</mi><mrow><mi>i</mi></mrow></msub></mrow></mfrac><mo data-mjx-texclass="CLOSE">)</mo></mrow></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mi></mi><mo>&lt;</mo><msub><mi>p</mi><mrow><mtext>tran,i&nbsp;</mtext><mo>,</mo><mi>i</mi></mrow></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>⩽</mo><msubsup><mi>p</mi><mrow><mtext>tran,i&nbsp;</mtext></mrow><mrow><mi>M</mi><mi>A</mi><mi>X</mi></mrow></msubsup><mo>,</mo><mi mathvariant="normal">∀</mi><mi>i</mi><mo>∈</mo><mi>N</mi></mtd></mtr></mtable></math>
</li>
<li><p>通过向前滑动窗口来更新PRQ。用户i在时隙t+K时间段生成的任务数量预测表示为：</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>X</mi><mo stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">{</mo><mtable columnalign="left" columnspacing="1em" rowspacing="4pt"><mtr><mtd><mi>X</mi><mo stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>,</mo><mi>k</mi><mo>=</mo><mi>K</mi></mtd></mtr><mtr><mtd><mi>X</mi><mo stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><msubsup><mi>O</mi><mrow><mi>k</mi></mrow><mrow><mi>i</mi></mrow></msubsup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>,</mo><mn>1</mn><mo>⩽</mo><mi>k</mi><mo>⩽</mo><mi>K</mi><mo>−</mo><mn>1</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE" fence="true" stretchy="true" symmetric="true"></mo></mrow></math>
</li>
<li><p>再到达时隙t+1时，预测数量$X(t + K +1)$是未知的，用户i的TBQ更新为：$B^i_{imd,q}(t+1)=[B^i_{imd,q}(t)-O^i_t(t)]^++[X(t+1)-O^i_t(t)].$</p>
</li>
<li><p>相应的OBQ更新为：$B^i_{imd,o}(t+1) = [B^i_{imd,o}(t) - R^i_imd]^+ +b^i_{imd,o}(t)$.</p>
<blockquote>
<p>$R^i_imd$为要卸载的任务数，$b^i_{imd,o}(t)$为在时隙t内OBQ内到达的任务数量。</p>
</blockquote>
</li>
<li><p>对于边缘节点，任务的平均等待时延为：$T^j_{av}(t) = \frac{C^j_{en,q}(t)}{\mathbb{E} (\sum_{x \in M_j R^x_{imd}(t)})}$.</p>
<blockquote>
<p>$C^j_{en,q}(t)$为边缘节点TBQ中的任务数量。</p>
</blockquote>
</li>
<li><p>忽略边缘节点与云的传输延迟。边缘节点的LBQ更新如下：$C^j_{en,q} = [C^j_{en,q} - c^j_{en,q}(t)-c^j_{en,o}(t)]^+ +\sum_{x \in M_j}R^x_{imd}.$</p>
<blockquote>
<p>$ c^j_{en,q}(t)$表示时隙t内边缘节点j中LBQ中的任务分布，$ c^j_{en,o}(t)$表示时隙t内边缘节点j中OBQ中的任务分布。</p>
</blockquote>
</li>
<li><p>边缘节点j中的OBQ更新：$C^j_{en,o}(t+1) = [C^j_{en,o}(t) - D^j_{en}]^+ + c^j_{en,o}(t).$</p>
</li>
<li><p>总时延：$T^i_{total}(t) = \sum_{i \in N}(t^i_{av}(t) + T^i_{tran}(t)) + \sum_{j \in M}T^j_{av}(t).$</p>
<blockquote>
<p>本地等待时延+传输时延+边缘节点的等待时延。</p>
</blockquote>
</li>
</ul>
<h3 id="能耗模型"><a href="#能耗模型" class="headerlink" title="能耗模型"></a>能耗模型</h3><p>用户的能耗主要由两部分组成：（1）计算能耗。（2）传输能耗。</p>
<ul>
<li>$P^i_{total}(t) = \sum_{i \in N} \varpi \vartheta (f_i(t))^3 + \sum_{j \in M} \sum_{i \in M_{imd,j} } \varpi  R^i_{imd},$</li>
</ul>
<blockquote>
<p>$\varpi$表示时隙的长度。$\vartheta$表示能耗系数。$R^i_{imd}$表示需要卸载的任务。</p>
</blockquote>
<h2 id="任务预测算法"><a href="#任务预测算法" class="headerlink" title="任务预测算法"></a>任务预测算法</h2><p>是用LSTM来进行任务预测。<br><img src = "
/UPOA/
图片3.png
" height = 300></p>
<ul>
<li>输入向量为数据包的大小和时间属性。表示为：$Input_{lstm} = [x^{m_1,t_1}_1,x^{m_2,t_2}_2,…,x^{m_p,t_p}_p].$</li>
<li><p>包含三层网络：一个隐藏层，两个LSTM层。每个LSTM层的每个时间步生成两个值，一个是当前的输出，一个是之前的累积输出。<br><img src = "
/UPOA/
图片4.png
" height = 300></p>
</li>
<li><p>LOSS：</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true" columnalign="right left right left right left right left right left right left" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" rowspacing="3pt"><mtr><mtd><mrow><mi data-mjx-variant="-tex-calligraphic" mathvariant="script">L</mi></mrow><mo stretchy="false">(</mo><mi>w</mi><mo>,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo></mtd><mtd><mi></mi><munder><mo data-mjx-texclass="OP">∑</mo><mrow><msub><mi>v</mi><mrow><msub><mi>x</mi><mrow><mi>i</mi></mrow></msub></mrow></msub><mo>∈</mo><mi>V</mi><mo>,</mo><mrow><mover><msub><mi>v</mi><mrow><msub><mi>x</mi><mrow><mi>i</mi></mrow></msub></mrow></msub><mo>^</mo></mover></mrow><mo>∈</mo><mrow><mover><mi>V</mi><mo>^</mo></mover></mrow></mrow></munder><msub><mi>v</mi><mrow><msub><mi>x</mi><mrow><mi>i</mi></mrow></msub></mrow></msub><msub><mi>log</mi><mrow><mn>2</mn></mrow></msub><mo data-mjx-texclass="NONE">⁡</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mrow><mover><msub><mi>v</mi><mrow><msub><mi>x</mi><mrow><mi>i</mi></mrow></msub></mrow></msub><mo>^</mo></mover></mrow><mo stretchy="false">(</mo><mi>w</mi><mo>,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>+</mo><mi>ξ</mi><mo data-mjx-texclass="CLOSE">)</mo></mrow></mtd></mtr><mtr><mtd></mtd><mtd><mi></mi><mo>+</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mn>1</mn><mo>−</mo><msub><mi>v</mi><mrow><msub><mi>x</mi><mrow><mi>i</mi></mrow></msub></mrow></msub><mo data-mjx-texclass="CLOSE">)</mo></mrow><msub><mi>log</mi><mrow><mn>2</mn></mrow></msub><mo data-mjx-texclass="NONE">⁡</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">(</mo><mn>1</mn><mo>−</mo><mrow><mover><msub><mi>v</mi><mrow><msub><mi>x</mi><mrow><mi>i</mi></mrow></msub></mrow></msub><mo>^</mo></mover></mrow><mo stretchy="false">(</mo><mi>w</mi><mo>,</mo><mi>u</mi><mo stretchy="false">)</mo><mo>+</mo><mi>ξ</mi><mo data-mjx-texclass="CLOSE">)</mo></mrow><mo>,</mo></mtd></mtr></mtable></math>

</li>
</ul>
<blockquote>
<p>$\xi = 1 \times 10^{-10}$.$w$为网络参数，$u$为数据包的输入和输出信息。</p>
</blockquote>
<p><img src = "
/UPOA/
图片5.png
" height = 400></p>
<h2 id="卸载算法"><a href="#卸载算法" class="headerlink" title="卸载算法"></a>卸载算法</h2><h3 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h3><p>将一个任务的数据包转换成向量A： $A=\{a_1,a_2,…,a_Q\}, a_q \in \{0,1\},\forall_q \in \{1,…,Q\}.$</p>
<blockquote>
<p>Q表示数据包的数量，$a_q$表示数据包的卸载策略，为0时在本地运算，为1时卸载。</p>
</blockquote>
<h3 id="卸载算法设计"><a href="#卸载算法设计" class="headerlink" title="卸载算法设计"></a>卸载算法设计</h3><p>基于粒子群优化算法(PSO)。然而，粒子群优化算法正在避免陷入局部最优的趋势。为了解决这个问题，通过添加一个变异算子来开发卸载算法，以防止自身陷入局部最优。</p>
<ul>
<li>目标函数：$F(X)=\sqrt{\frac{F_T^{max} - F_T(x)}{F_T^{max} - F_T^{min}} \cdot \frac{F_P^{max} - F_P(x)}{F_P^{max} - F_P^{min}}}$</li>
</ul>
<blockquote>
<p>$F_T(x)$表示延迟，$F_P(x)$表示能耗。$F_T^{max},F_T^{min}$表示$F_T(x)$的最大最小值。$F_P^{max},F_P^{min}$表示$F_P(x)$的最大最小值。</p>
</blockquote>
<ul>
<li>在每个时隙$F(x)=1$表示最优卸载策略，为0则表示策略不可行。目标是让$F(x)$尽可能接近1。</li>
</ul>
<h3 id="加法运算符"><a href="#加法运算符" class="headerlink" title="加法运算符"></a>加法运算符</h3><ul>
<li><p>让$A^{new}$表示新的卸载策略A。$A^{new}$由旧卸载策略A和粒子速度矢量V来决定(19)：</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>A</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msup><mo>=</mo><mi>A</mi><mo>+</mo><mi>V</mi><mo>,</mo><msubsup><mi>a</mi><mi>q</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msubsup><mo>=</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">{</mo><mtable columnalign="left left" columnspacing="1em" rowspacing=".2em"><mtr><mtd><msub><mi>a</mi><mi>q</mi></msub><mo>,</mo><msub><mi>v</mi><mi>q</mi></msub><mo>=</mo><mn>2</mn></mtd></mtr><mtr><mtd><msub><mi>v</mi><mi>q</mi></msub><mo>,</mo><msub><mi>v</mi><mi>q</mi></msub><mo>=</mo><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>e</mi></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE" fence="true" stretchy="true" symmetric="true"></mo></mrow><mo>,</mo></math>
</li>
<li><p>V是粒子速度的一维矢量，$V=\{v_1,v_2,…,v_Q\}, v_q \in \{0,1,2\},\forall_q \in \{1,…,Q\}$</p>
</li>
</ul>
<blockquote>
<p>$v_i=2$表示粒子i不变。也就是说卸载策略不改变。否则粒子位置将更新为$v_q$</p>
</blockquote>
<h3 id="减法运算符"><a href="#减法运算符" class="headerlink" title="减法运算符"></a>减法运算符</h3><ul>
<li>粒子的速度可以从粒子位置获得(21)：<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>V</mi><mo>=</mo><msup><mi>A</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msup><mo>−</mo><mi>A</mi><mo>,</mo><msubsup><mi>v</mi><mi>q</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msubsup><mo>=</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">{</mo><mtable columnalign="left left" columnspacing="1em" rowspacing=".2em"><mtr><mtd><mn>2</mn><mo>,</mo><msubsup><mi>a</mi><mi>q</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msubsup><mo>=</mo><msub><mi>a</mi><mi>q</mi></msub></mtd></mtr><mtr><mtd><msubsup><mi>a</mi><mi>q</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msubsup><mo>,</mo><msubsup><mi>a</mi><mi>q</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msubsup><mo>=</mo><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>e</mi></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE" fence="true" stretchy="true" symmetric="true"></mo></mrow><mo>,</mo></math>

</li>
</ul>
<h3 id="变异算子"><a href="#变异算子" class="headerlink" title="变异算子"></a>变异算子</h3><p>由于原粒子群算法收敛速度太快，很容易陷入局部最优。因此添加了一个变异算子，以提高原始PSO的性能。</p>
<ul>
<li>$V^M = A \oplus A^{local}$(异或).$A^{local}$是局部最优策略。</li>
<li><p>$V^M$中的每个粒子速度$v^M_q$可以表示为(22)：</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msubsup><mi>v</mi><mrow><mi>q</mi></mrow><mrow><mi>M</mi></mrow></msubsup><mo>=</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">{</mo><mtable columnalign="left" columnspacing="1em" rowspacing="4pt"><mtr><mtd><msubsup><mi>a</mi><mrow><mi>q</mi></mrow><mrow><mtext>local&nbsp;</mtext></mrow></msubsup><mo>,</mo><msubsup><mi>a</mi><mrow><mi>q</mi></mrow><mrow><mtext>local&nbsp;</mtext></mrow></msubsup><mo>≠</mo><msub><mi>a</mi><mrow><mi>q</mi></mrow></msub><mo>,</mo><msubsup><mi>a</mi><mrow><mi>q</mi></mrow><mrow><mtext>local&nbsp;</mtext></mrow></msubsup><mo>∈</mo><msup><mi>A</mi><mrow><mtext>local&nbsp;</mtext></mrow></msup></mtd></mtr><mtr><mtd><mn>1</mn><mo>−</mo><msubsup><mi>a</mi><mrow><mi>q</mi></mrow><mrow><mtext>local&nbsp;</mtext></mrow></msubsup><mo>,</mo><mtext>&nbsp;otherwise&nbsp;</mtext></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE" fence="true" stretchy="true" symmetric="true"></mo></mrow></math>
</li>
<li><p>判断突变的条件是D小于非常小的数，表示为$D &lt; \theta$。$D = 1- \frac{1}{Q(Q-1)\sum_{i=1}^Q \sum_{j ≠ i}^Q S_{i,j}}.$</p>
</li>
</ul>
<blockquote>
<p>D可以理解为每个粒子卸载策略的相似性。</p>
</blockquote>
<ul>
<li>$S_{i j}=\left|\left\{a_{i q} \mid a_{i q}=a_{j q}, \forall q \in\{1, \cdots Q\}\right\}\right|$.</li>
</ul>
<blockquote>
<p>可以理解为相似性。</p>
</blockquote>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul>
<li>假设$A = \{1,0,0,1,1\}.$</li>
<li>速度$V = \{0,1,1,1,2\}.$</li>
<li>根据(19)，新的卸载策略为：$A^{new} = \{0,1,1,1,1\}.$</li>
<li>通过$A$和$A^{new}$和(21)可以得到速度$V^{new}=\{0,1,1,2,2\}.$</li>
<li>如果$A^{local} = \{1,0,1,0,1\}$,</li>
<li>变异操作后的粒子速度为：$V^M=\{0,1,1,0,0\}$.</li>
<li>进行加法操作后新的卸载策略为：$A^{new} = {0,1,1,0,0}$.</li>
</ul>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p><img src = "
/UPOA/
图片6.png
" height = 700></p>
<ul>
<li>step1:确定用户偏好：根据IMD的电池电量状态，根据用户偏好值设置等式1中α和β的权重（参见算法2中的第2行）;</li>
<li>step2:获得预测结果：任务预测算法（算法1）预测将在未来K时间窗口到达的任务（参见算法2中的第3行）;</li>
<li>step3:制定卸载策略：<ul>
<li>首先随机初始化每个粒子的位置（参见算法2中的第4-9行）;<ul>
<li>7:将目前的卸载位置设为历史最佳策略。</li>
</ul>
</li>
<li>执行粒子适应度函数（参见算法2中的第10-19行）。<ul>
<li>$Gbest_i$：全局最佳策略；</li>
<li>$Pbest_i$：历史最佳策略；</li>
<li>10：更新全局策略；</li>
<li>13:计算个体适应度F(x);</li>
<li>14:更新最佳历史策略；</li>
<li>17:更新全局最佳策略；</li>
</ul>
</li>
<li>更新粒子位置（参见Algorithm2中的第20-21行。</li>
<li>判断是否需要调用变异操作（参见算法2中的第22-24行）。</li>
</ul>
</li>
</ul>
<h1 id="实验模拟"><a href="#实验模拟" class="headerlink" title="实验模拟"></a>实验模拟</h1><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>文章建立了一个真实的云边缘系统来评估我们的UPOA的性能。使用五部智能手机作为IMD（见表4）。我们设置了两个EN，每个EN都由一个小型工作站组成。该光盘由阿里云上运行的五个配置相同的云节点构建。表5总结了EN和CD的配置。图5为卸载任务的信息。<br><img src = "
/UPOA/
图片7.png
" height = 300></p>
<p><img src = "
/UPOA/
图片8.png
" height = 400></p>
<p><img src = "
/UPOA/
图片9.png
" height = 300></p>
<h2 id="对比算法"><a href="#对比算法" class="headerlink" title="对比算法"></a>对比算法</h2><ul>
<li>MUDRL(A Multi-update Deep Reinforcement Learning Ap-proach)：优化目标为降低延迟。基于DDQN。2020.</li>
<li>DRL(A Double-Q Deep Reinforcement Learning Approach):基于DDQN。2020.</li>
<li>DRL-E2D(A DRL-based Model-free Task Offloading Approach):基于k近邻算法。2021.</li>
</ul>
<h3 id="模拟结果"><a href="#模拟结果" class="headerlink" title="模拟结果"></a>模拟结果</h3><p><img src = "
/UPOA/
图片10.png
" ></p>
<p>不同偏好对UPOA的影响。</p>
<ul>
<li>(a)：能量状态为[100%,50%]时，所有三种方案都会优化延迟，以满足用户对低延迟的需求。其中高敏感方案的延迟最高。</li>
<li>(b)显示了UPOA在三种不同的方案下的节能性能。(值越高越好)。当能量状态为[100%,50%]时，三种方案的能量优化程度较低。当能源状态为[50%，0%]时，三种方案转向能源优化。结合这两个图的结果，它清楚地表明，当能量消耗到低水平（能量状态为[20%，0%]）时，这三种方案几乎都牺牲了延迟减少，以进一步节能。</li>
<li>对于中敏感度方案，当能量状态处于[100%,60%]时，延迟权重为0.85或0.65，为了得到更低的延迟，会把更多的数据包传输到边缘节点，而不是在本地计算。<br><img src = "
/UPOA/
图片11.png
"></li>
<li>(a):延迟随着CPU频率的增加而减少。随着CPU频率的增加，可以在本地计算更多的任务，这会减少IMD LBQ中的任务数，从而缩短等待延迟。</li>
<li><p>(b):不同CPU频率下四种方法的平均能耗。能源消耗的增加不受传输速度的限制。这是因为如果不对CPU应用节能技术，即使IMD LBQ中的任务很快完成，CPU在等待新任务时也会继续以高频率运行，这会导致更多的能耗。<br><img src = "
/UPOA/
图片12.png
"></p>
</li>
<li><p>(a)：平均延迟随着数据包大小的增长而增加。upoa处于DRL-E2D和MUDRL之间。数据包越大，等待延迟越长。卸载的传输时间就越长。</p>
<ul>
<li>DRL-E2D的奖励功能更注重任务的完成率。任务传输时间的增加会降低任务的完成率。奖励功能将优化能量消耗，以获得更好的奖励值，从而增加更多延迟。</li>
<li>MUDRL只关注延迟：随着数据包大小的增长，MUDRL会不断增加CPU功率，直到达到最大值。这种机制有效地减少了等待延迟和卸载延迟，但比其他两种方法消耗更多的能量。</li>
<li>DRA的奖励功能考虑了任务的最大延迟。因此，当使用DRA方法时，CPU的能耗随着数据包大小的增加而增加。</li>
</ul>
</li>
<li>(b):能耗随着数据包大小的增长而增加。</li>
</ul>
<p><img src = "
/UPOA/
图片13.png
"></p>
<ul>
<li>在电量充足时的对比，电池电量高的用户更喜欢低延迟。</li>
</ul>
<p><img src = "
/UPOA/
图片14.png
"></p>
<ul>
<li>电量低和极地状态下的对比。<ul>
<li>可以看到UPOA对能量的保存时最好的。</li>
<li>如果在极低的电池间隔中不卸载方法，电池的平均寿命只有2.6分钟。相比之下，UPOA的平均寿命增加到5.8分钟，额外增加了3.2分钟的时间，这将极低电池间隔的电池寿命延长123.07%。</li>
</ul>
</li>
</ul>
<p><img src = "
/UPOA/
图片14.png
"></p>
<ul>
<li>用户设备寿命期间的CPU利用率。每条线上的圆点代表寿命耗尽。</li>
<li>可以看出UPOA是最稳定和最低的。    </li>
</ul>
<h1 id="论文地址"><a href="#论文地址" class="headerlink" title="论文地址"></a>论文地址</h1><p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9839413">Yuan, Jingling, et al. “UPOA: A User Preference Based Latency and Energy Aware Intelligent Offloading Approach for Cloud-edge Systems.” IEEE Transactions on Cloud Computing (2022)</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/" rel="tag"># 文献阅读</a>
              <a href="/tags/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/" rel="tag"># 边缘计算</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E5%8D%B8%E8%BD%BD/" rel="tag"># 计算卸载</a>
              <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag"># 深度学习</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/09/07/%5Bpython%5Dsklearn%E4%B8%AD%E9%A2%84%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/" rel="prev" title="[python]sklearn中归一化与标准化">
                  <i class="fa fa-chevron-left"></i> [python]sklearn中归一化与标准化
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/09/20/%5B%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%5D%E7%B2%92%E5%AD%90%E7%BE%A4%E4%BC%98%E5%8C%96(PSO)/" rel="next" title="[算法笔记]粒子群优化(PSO)">
                  [算法笔记]粒子群优化(PSO) <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81NTkwNy8zMjM3MQ=="></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ciallo～(∠・ω< )⌒☆​</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"mhchem":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script src="/js/third-party/comments/livere.js"></script>

</body>
</html>
