<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="[JVM]JVM">
<meta property="og:url" content="http://example.com/2021/04/24/[JVM]JVM/index.html">
<meta property="og:site_name" content="生灵">
<meta property="og:description" content="JVM">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-04-24T06:27:05.000Z">
<meta property="article:modified_time" content="2023-04-05T12:53:36.870Z">
<meta property="article:author" content="Ciallo～(∠・ω&lt; )⌒☆​">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2021/04/24/[JVM]JVM/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2021/04/24/[JVM]JVM/","path":"2021/04/24/[JVM]JVM/","title":"[JVM]JVM"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>[JVM]JVM | 生灵</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">生灵</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>目录</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">跨平台原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">字节码的作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">JVM的整体结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.</span> <span class="nav-text">类加载子系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">4.1.</span> <span class="nav-text">类加载器的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE"><span class="nav-number">4.2.</span> <span class="nav-text">双亲委派</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tomacat%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">4.3.</span> <span class="nav-text">Tomacat为什么要自定义加载器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="nav-number">5.</span> <span class="nav-text">运行时的数据区</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">5.1.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">5.2.</span> <span class="nav-text">虚拟机栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%B8%A7"><span class="nav-number">5.3.</span> <span class="nav-text">栈帧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="nav-number">5.3.1.</span> <span class="nav-text">局部变量表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="nav-number">5.3.2.</span> <span class="nav-text">操作数栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-number">5.3.3.</span> <span class="nav-text">本地方法栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E5%8C%BA"><span class="nav-number">5.4.</span> <span class="nav-text">堆区</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">6.</span> <span class="nav-text">为什么要进行垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-number">6.1.</span> <span class="nav-text">引用计数法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95"><span class="nav-number">6.2.</span> <span class="nav-text">可达性分析法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">6.3.</span> <span class="nav-text">回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">6.3.1.</span> <span class="nav-text">标记-清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">6.3.2.</span> <span class="nav-text">复制算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="nav-number">6.3.3.</span> <span class="nav-text">标记-整理算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83"><span class="nav-number">6.3.4.</span> <span class="nav-text">回收算法比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">6.4.</span> <span class="nav-text">分代收集算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">6.5.</span> <span class="nav-text">常用的垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Parellel-Gc-%E5%92%8C-Parallel-Old-GC"><span class="nav-number">6.5.1.</span> <span class="nav-text">Parellel Gc 和 Parallel Old GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS"><span class="nav-number">6.5.2.</span> <span class="nav-text">CMS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1"><span class="nav-number">6.5.3.</span> <span class="nav-text">G1</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ciallo～(∠・ω< )⌒☆​"
      src="/images/dh.png">
  <p class="site-author-name" itemprop="name">Ciallo～(∠・ω< )⌒☆​</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">目录</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/24/[JVM]JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/dh.png">
      <meta itemprop="name" content="Ciallo～(∠・ω< )⌒☆​">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="生灵">
      <meta itemprop="description" content="">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="[JVM]JVM | 生灵">
      <meta itemprop="description" content="JVM">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          [JVM]JVM
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-24 14:27:05" itemprop="dateCreated datePublished" datetime="2021-04-24T14:27:05+08:00">2021-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-05 20:53:36" itemprop="dateModified" datetime="2023-04-05T20:53:36+08:00">2023-04-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">收录于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">JVM</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="跨平台原理"><a href="#跨平台原理" class="headerlink" title="跨平台原理"></a>跨平台原理</h1><p><img src = "
/JAVA/
图片2.png
"></p>
<ul>
<li>JJVM就是⼀个运⾏在操作系统上的程序，JDK和JRE就是JVM的安装包，⽽我们运⾏java命令就能运⾏JVM，不管操作系统是什么，JVM运⾏起来后提供的功能是⼀样的，都是⽤来执⾏代码的。</li>
<li>不同操作系统上运行的JVM是不一样的，这就是JVM跨平台的本质。</li>
<li>我们写一份JAVA代码，编译成字节码，不同操作系统上的JVM都能运行字节码，相当于不同操作系统上的JVM屏蔽了不同操作系统的底层区别。</li>
</ul>
<h1 id="字节码的作用"><a href="#字节码的作用" class="headerlink" title="字节码的作用"></a>字节码的作用</h1><p><img src = "
/JAVA/
图片3.png
" height = 400></p>
<ul>
<li>JVM会逐行解释字节码。如果直接将Java代码翻译成机器指令，效率会大大降低。所以要提前对Java代码进行编译，编译成字节码，字节码再翻译成机器指令，效率比较高。Java其实是变异+解释二合一的语言。</li>
</ul>
<h1 id="JVM的整体结构"><a href="#JVM的整体结构" class="headerlink" title="JVM的整体结构"></a>JVM的整体结构</h1><p><img src = "
/JAVA/
图片4.png
" height = 400></p>
<ul>
<li>先将java文件编译成class文件</li>
<li>类加载器将class文件加载到方法区中</li>
<li>解析器逐行执行字节码。<ul>
<li>每执行一个Java方法，就将方法存入Java栈中。</li>
<li>每执行一个本地方法，也就是native方法，就将方法存入本地方法栈总。</li>
<li>方法执行完后就从栈中移除</li>
</ul>
</li>
<li>程序计数器用于记录带执行的吓一条字节码指令地址。</li>
<li>方法执行过程中产生的Java对象会存入堆中</li>
<li>垃圾回收器会回收已经没有被使用的Java对象。</li>
<li>JIT编译器会在程序运行过程中发现热点代码，病编译成机器指令，从而提高执行效率。</li>
</ul>
<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><p><img src = "
/JAVA/
图片5.png
" height = 400></p>
<ul>
<li>类加载子系统会将某个class文件加载到方法去中的内存空间中，可以理解为把class文件中字节码指令，读取到内存中。</li>
<li>验证阶段会验证到家在的class文件是否正确，比如验证文件格式。</li>
<li>准备阶段会为static变量分配呢困并赋零值。</li>
<li>解析阶段会将符号引用解析为直接引用，在一个字节码文件中，会用到其他类，而在字节码中只会存用到类的类名，而解析阶段就是会根据类名找到该类加载后再方法区中的地址，也就是直接印哟过，并替换符号引用。</li>
<li>初始化阶段会给static变量赋值，并执行static块。</li>
</ul>
<h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><p><img src = "
/JAVA/
图片6.png
" height = 400></p>
<ul>
<li>JVM规范中，把类加载器分为两种：<ul>
<li>BootStrapClassLoader：由C和C++实现，负载加载jre/lib下的jar包中的类，比如rt.jar中的String类。</li>
<li>一种是继承了ClassLoader抽象类的加载器，是由Java语言实现的，比如：<ul>
<li>ExtClassLoader，加载jre/lib/ext目录下的类。</li>
<li>AppClassLoader，加载目录为classpath所制定的目录。</li>
<li>其他自定义的，比如Tomacat中的WebAppClassLoader</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src = "
/JAVA/
图片7.png
" height = 400><br>通过继承URLClassLoader，最终间接继承了ClassLoader。</p>
<h2 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h2><p><img src = "
/JAVA/
图片8.png
" height = 400><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    <span class="title function_">synchronized</span> <span class="params">(getClassLoadingLock(name)</span>) &#123;</span><br><span class="line">        <span class="comment">//首先，检查类是否被加载了</span></span><br><span class="line">Class&lt;?&gt; c = findLoadedClass(name); <span class="keyword">if</span>(c==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// parent有值则直接委托给parent去加载，否则委托给BootstrapCLassLoader去加载 </span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0)</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1)</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> c; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>这段代码体现了双亲委派。</p>
<ul>
<li>通过我们用AppClassLoader去加载一个类时，AppCLassLoader有一个parent属性指向了ExtClassLoader。会先委派给ExtClassLoader去加载。</li>
<li>而ExtClassLoader没有parent属性，所以会委派给BootStrapClassLoader去加载。</li>
<li>只有BootStrapClassLoader没有加载到，才会由ExtClassLoader去加载。</li>
<li>也只有ExtClassLoader没有加载到，才会有AppClassLoader去加载。</li>
</ul>
</li>
<li><p>双亲委派的优点：</p>
<ul>
<li>避免类的重复加载，如果一个类被ootStrapClassLoader加载过了，那么AppClassLoader就不会再加载到这个类类。</li>
<li>防止API被篡改，自定义一个java.lang.String类，但是我们是用不到这个类的，因为根据双亲委派始终加载的都是rt.jar中的hava.lang.String类。</li>
</ul>
</li>
</ul>
<h2 id="Tomacat为什么要自定义加载器"><a href="#Tomacat为什么要自定义加载器" class="headerlink" title="Tomacat为什么要自定义加载器"></a>Tomacat为什么要自定义加载器</h2><p>为了进行类的隔离，如果Tomact直接使用AppClassLoader类加载类，那会出现如下情况：</p>
<ul>
<li>1.应用A中有一个com.zhouyu.Hello.class</li>
<li>2.应用B中有一个com.zhouyu.Hello.class</li>
<li>3.虽然都叫做Hello，但是具体的方法、属性可能不一样。</li>
<li>4.如果AppClassLoader先加载了应用A中的hello.class</li>
<li>5.那么引用B中的hello.class就不可能再被加载了，因为名字一样。</li>
<li>6.如果就需要针对应用A和应用B设置个字单独的类加载器，也就是WebappClassLoader.</li>
<li>7.这样两个应用中的Hello.class都能被鸽子的类加载器所加载，不会冲突。</li>
<li>8.这就是Tomact为什么用自定义类加载器的核心原因，为了实现类加载的隔离。</li>
<li>9.JVM中判断一个类是不是已经被加载的逻辑是：类名+对于的类加载器实例。</li>
</ul>
<h1 id="运行时的数据区"><a href="#运行时的数据区" class="headerlink" title="运行时的数据区"></a>运行时的数据区</h1><p><img src = "
/JAVA/
图片9.png
" height = 400></p>
<ul>
<li>本地方法栈、Java方法栈、程序计数器时每个线程单独的区域。</li>
<li>方法区、堆区市所有线程共享的区域。</li>
</ul>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>PC Register，程序计数器寄存器，简称为程序计数器：</p>
<ul>
<li>1.是物理寄存器的抽象实现</li>
<li>2.用来记录待执行的吓一跳指令的地址</li>
<li>3.他是程序控制流的指示器，循环、ifelse、异常处理、线程恢复等都依赖它来完成。</li>
<li>4.解释器工作时就是通过它来获取下一条需要执行的字节码指令。</li>
<li>5.它是唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域。</li>
</ul>
<p><img src = "
/JAVA/
图片10.png
" height = 400><br>JVM的解释器在解释执行字节码指令时，会从程序计数器中取出接下来要执行的指令行号，并且将下一条指令的行号保存到程序计数器中，然后开始执行刚刚取出来的指令。</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><ul>
<li>也可以被称为Java栈、Java方法栈(跟本地方法栈对比)</li>
<li>每个线程在创建时，都会创建一个虚拟机栈，栈内会保存一个个的栈帧，每个栈帧对应一个方法：</li>
<li>1.虚拟机栈时私有的</li>
<li>2.一个方法开始执行栈帧时入栈、方法执行完后对应的栈帧出栈，所以虚拟机不需要对应的垃圾回收。</li>
<li>3.虚拟机栈存在OutOfMenmoryError、以及StackOverflowError</li>
<li>4.线程太多，就可能会出现OutOfMenmoryError，线程创建时就没有足够的内存区创建虚拟机栈了。</li>
<li>5.方法调用层次太多，就可能出现StackOverflowError。</li>
<li>6.可以通过-Xss来设置虚拟机栈大小。</li>
</ul>
<p><img src = "
/JAVA/
图片11.png
" height = 400></p>
<ul>
<li>执行方法1时，会生成一个栈帧1入栈。</li>
<li>如果方法1中调用了方法2，那么又会生成一个栈帧2入栈。</li>
<li>如果方法2中调用了方法3，那么又会生成一个栈帧3入栈。</li>
<li>如果方法3中调用了方法4，那么又会生成一个栈帧4入栈。</li>
<li>方法4真正执行完或抛出异常后，对应的栈帧4就会出栈，并且会把方法的执行结果或者异常传给栈帧3以此类推，最后方法1执行完后，当前线程的虚拟机栈中就灭有东西了，最后线程也会退出。</li>
</ul>
<h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p><img src = "
/JAVA/
图片12.png
" height = 400></p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p><img src = "
/JAVA/
图片13.png
" height = 400></p>
<ul>
<li>局部变量表local variables。其实就是列表，是数组的意思。主要用来保存方法参数和方法内的局部变量，要么是基本数据类型，要么是引用地址。</li>
<li>局部变量表所需的内存大小在编译器就确定下来了。根据参数类型和变量类型确定，可以在字节码中看到，不过字节码中的局部变量表中只存了局部变量的位置，没有存值。</li>
<li>局部变量表中基本的存储单位是Slot，每个Slot可以存储一个占32bit的值，像double类型的数字就需要两个Slot才能存，对象的引用地址也是存在Slot中的，占一个Slot。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.1f</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对应的字节码中就记录了局部变量表<br><img src = "
/JAVA/
图片14.png
"></li>
<li>1.可以看到args是方法参数，占0个Slot</li>
<li>2.变量d是double类型，占1，2个Slot</li>
<li>3.变量o是一个对象，占第3个Slot，Slot中对象的引用地址</li>
<li>4.变量i是一个int类型，占第4个Slot。</li>
</ul>
<p>因此，方法参数和局部变量越多，那么栈帧也就越大，也就越容易出现栈溢出，另外，局部变量表总的变量也是重要的垃圾回收根节点，只要被局部变量表直接或间接引用的对象就不会回收。</p>
<ul>
<li>另外，如果方法不是static方法，那么局部变量的第0个Slot存的是this：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String args)</span>&#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.1f</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src = "
/JAVA/
图片15.png
" height = 400></li>
</ul>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈，OperandStack，也可以叫操作栈，也是栈帧的一部分，操作数栈是用来执行字节码指令过程中用来临时存数据并用来计算的。 </p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul>
<li>本地方法： native method，在Java定义的方法中，但由其他语言实现。</li>
<li>虚拟机栈存的是Java方法调用过程的栈帧，本地方法栈存的是本地方法调用过程中的栈帧。</li>
<li>也是线程私有的，也有可能出现OOM和SOF。</li>
</ul>
<h2 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h2><p><img src = "
/JAVA/
图片16.png
" ></p>
<ul>
<li>JVM规范中所有的对象和数组都应该存放在堆中。</li>
<li>在执行字节码指令时，会把创建的对象存入堆中，对象对应的引用地址存入虚拟机栈中的栈帧中。</li>
<li>方法执行完后，刚刚所创建的对象并不会立马被回收，而要等JVM后台执行GC后，对象才会被回收。</li>
</ul>
<p>我们可以通过：</p>
<ul>
<li>Xms：制定堆的初始化大小</li>
<li>Xmx：制定堆的最大内存大小</li>
</ul>
<p>一般会把-Xms和-Xmx设置为一样，这样JVM就不需要在GC后区修改堆的内存大小了，提高了效率。一般情况下，初始化内存大小=物理内存大小/64，最大内存大小大小=物理内存大小/4.</p>
<ul>
<li>新生代一般存的是刚刚创建的对象。</li>
<li>老年代存的是一些经过多次垃圾回收后还活着的对象。</li>
<li>通过-XX：NewRatio参数来配置新生代和老年代的比例，默认为2，新生代占1，老年代占2，也就是新生代占堆区总大小的1/3.</li>
<li><p>一般是不需要调整的，只有明确知道存活时间比较长的对象偏多，那么就需要调大NewRatio，从而调整老年代的占比。</p>
</li>
<li><p>Eden：伊甸区，新对象都会先放到Eden区(除非对象的大小都超过了Eden区，那么就直接放进老年代)</p>
</li>
<li>S0，S1:Surivivor0，Survivor1，也可以叫做from区，to区，用来存放MinorGC(YGC)后存放的对象。</li>
<li><p>默认情况下(Ednen:S0:S1)的比例大小关系为(8:1:1)。也可以通过-XX:SurvivorRatio来调整。</p>
</li>
<li><p>过程：</p>
<ul>
<li>开始先放入Eden区，</li>
<li>一次YGC后，存活的对象进入S0区，</li>
<li>再次YGC后，存活的对象进入S1区</li>
<li>多次YGC后，存活的对象进入老年代区</li>
</ul>
</li>
<li><p>Young GC/Minor GC:负责对新生代进行垃圾回收</p>
</li>
<li>Old GC/Major GC：负责对老年代进行垃圾回收，目前只有CMS垃圾收集器会单独对老年代进行垃圾收集，其他垃圾收集器基本都是整堆回收的时候堆老年代进行垃圾收集。</li>
<li>Full GC：整堆回收，也会对堆方法区进行垃圾回收。</li>
<li>Eden区满了之后，就会进行YGC，YGC时会STW(Stop The World)，会占停用户线程，YGC执行频率一般比较高，但是执行的速度比较快。</li>
<li><p>老年代满了之后，就会触发Full GC，一般会在Full GC之前执行一次YGC，Full GC也会STW，并且速度较慢，所以要尽可能避免Full GC，如果Full GC后，内存还是不足，那么就会报OOM了。</p>
</li>
<li><p>特殊情况1:如果TGC后，Eden区又存活对象，需要保存到S0区，但是S0剩余空间不够，那么这个对象会直接放到老年代。<br><img src = "
/JAVA/
图片17.png
" ></p>
</li>
<li><p>特殊情况2:如果有一次超大对象，比Eden区的范围都要大，会直接放到老年代，如果老年代放不下，会进行FGC，FGC后如果老年代放不下就回报OOM。<br><img src = "
/JAVA/
图片18.png
"></p>
</li>
</ul>
<h1 id="为什么要进行垃圾回收"><a href="#为什么要进行垃圾回收" class="headerlink" title="为什么要进行垃圾回收"></a>为什么要进行垃圾回收</h1><p>垃圾是指在JVM中没有任何引用指向它的对象，如果不清理这些垃圾对象，那么它们就一直占用着内存，而不能给其他对象使用，最终垃圾对象越来越多，就会出现OOM。</p>
<h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>每个对象都保存一个引用计数器属性，用户记录对象被引用的次数。</p>
<ul>
<li>优点：实现简单，计数器为0则表示是垃圾对象</li>
<li>缺点：<ul>
<li>需要额外的空间来存储计数器。</li>
<li>需要额外的时间来维护引用计数器。</li>
<li>最严重的问题：无法处理循环引用的问题。假设两个对象一直相互引用，计数器就一直是1，但又没有其他对象来引用这两个对象（实际是垃圾对象）。<br><img src = "
/JAVA/
图片19.png
"></li>
</ul>
</li>
</ul>
<h2 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h2><p> 会以GC Roots作为起始点，然后一层一层找到所引用的对象，被找到的对象就是存活对象，那么其他不可达的对象就是垃圾对象。<br> <img src = "
/JAVA/
图片20.png
"></p>
<ul>
<li>GC Roots包括哪些：<ul>
<li>线程中虚拟机栈中正在执行的方法中方法参数、局部变量所对应的对象引用。</li>
<li>线程中本地方法中正在执行的方法中方法参数、局部变量所对应的对象引用。</li>
<li>方法区中保存的类信息中静态属性所对应的对象引用。</li>
<li>方法区中保存的类信息中常量属性所对应的对象引用。 </li>
</ul>
</li>
</ul>
<h2 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>找到垃圾对象怎么进行回收。</p>
<p>一种非常基础和常用的垃圾回收算法，针对某块内存空间，比如新生代、老年代，如果可用内存不足后，酒会STW，暂停用户线程的执行，然后执行算法进行垃圾回收：</p>
<ul>
<li>1.标记阶段：从GC Roots开始遍历，找到可达对象，并在对象头中进行记录。</li>
<li><p>2.清楚阶段：堆内存空间进行线性便利，如果发现对象投中没有记录是可达对象，则回收他。<br><img src = "
/JAVA/
图片21.png
"></p>
</li>
<li><p>缺点：</p>
<ul>
<li>效率不高</li>
<li>内存碎片：会产生一块一块的小内存，导致无法使用。</li>
</ul>
</li>
<li><p>优点：思路简单</p>
</li>
</ul>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将内存空间分为两两块，每次只使用一块，在进行垃圾回收时，将可达对象复制到另外没有被使用的内存块中，然后再清楚当前内存卡中的所有对象，后续再按同样的流程进行垃圾回收，交换着来。<br> <img src = "
/JAVA/
图片22.png
"></p>
<ul>
<li>优点：<ul>
<li>1.没有标记和清楚阶段，通过GC Roots找到可达对象，直接复制，不需要修改对象头，效率高。</li>
<li>2.不会出现内存碎片。</li>
</ul>
</li>
<li>缺点：<ul>
<li>1.需要更多的内存，始终有一半的内存空闲。</li>
<li>2.对象复制后，对象存放的内存地址发生了变化，需要额外的时间修改栈帧中记录的引用地址。</li>
<li>3.如果可达对象比较多，垃圾对象比较少，那么复制算法的效率就会比较低，所以垃圾对象多的情况下，复制算法比较合适。</li>
</ul>
</li>
</ul>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><ul>
<li>第一阶段和标记-清除算法一样，从GC Roots找到并标记可达对象。</li>
<li>第二阶段将所有存活对象移动到内存的一端。</li>
<li>最后清理边界外所有的空间。<br><img src = "
/JAVA/
图片23.png
"><br>相当于标记-清除算法执行完一次之后再进行一次内存整理。</li>
<li>优点：<ul>
<li>1.不会出现内存碎片。</li>
<li>2.也不需要利用额外的空间。</li>
</ul>
</li>
<li>缺点：<ul>
<li>1.效率相对较低。</li>
<li>2.也需要修改栈帧中的引用地址。</li>
</ul>
</li>
</ul>
<h3 id="回收算法比较"><a href="#回收算法比较" class="headerlink" title="回收算法比较"></a>回收算法比较</h3><p> <img src = "
/JAVA/
图片24.png
"></p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><ul>
<li>不同的对象存活时间是不一样的，也就可以针对不同的对象采取不同的垃圾回收算法。</li>
<li>默认几乎所有的垃圾收集器都是采用分代收集算法进行垃圾回收的。</li>
<li>我们会把堆分为新生代和老年底代：<ul>
<li>1.新生代中的对象存活时间比较短，那么就可以利用复制算法，它适合垃圾对象比较多的情况。</li>
<li>2.老年代中的对象存活时间比较长，所以不太适合用复制算法，可以哟过标记-清除或标记-整理算法，比如：<ul>
<li>CMS垃圾收集器采用的就是标记-清除算法。</li>
<li>Serial Old垃圾收集器采用的就是标记-整理算法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="常用的垃圾收集器"><a href="#常用的垃圾收集器" class="headerlink" title="常用的垃圾收集器"></a>常用的垃圾收集器</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">回收器</th>
<th style="text-align:left">串/并行</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">新生。老年代</th>
<th style="text-align:left">算法</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Serial GC</td>
<td style="text-align:left">串行</td>
<td style="text-align:left">工作线程暂停，一个线程进行垃圾回收</td>
<td style="text-align:left">新生代</td>
<td style="text-align:left">复制算法</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">Serial Old GC</td>
<td style="text-align:left">串行</td>
<td style="text-align:left">工作线程暂停，一个线程进行垃圾回收</td>
<td style="text-align:left">新生代</td>
<td style="text-align:left">标记-整理</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">ParNew GC</td>
<td style="text-align:left">并行</td>
<td style="text-align:left">工作线程暂停，多个线程进行垃圾回收</td>
<td style="text-align:left">新生代</td>
<td style="text-align:left">复制算法</td>
<td style="text-align:left">Serial GC的多线程版</td>
</tr>
<tr>
<td style="text-align:center">CMS GC</td>
<td style="text-align:left">并行</td>
<td style="text-align:left">用户线程和垃圾回收线程同时进行</td>
<td style="text-align:left">老生代</td>
<td style="text-align:left">标记-清除算法</td>
<td style="text-align:left">低暂停</td>
</tr>
<tr>
<td style="text-align:center">Parallel GC</td>
<td style="text-align:left">并行</td>
<td style="text-align:left">工作线程暂停，多个线程进行垃圾回收</td>
<td style="text-align:left">新生代</td>
<td style="text-align:left">复制算法</td>
<td style="text-align:left">和ParNew相比，能动态调整内存分配情况，JDK8默认</td>
</tr>
<tr>
<td style="text-align:center">Parallel Old GC</td>
<td style="text-align:left">并行</td>
<td style="text-align:left">工作线程暂停，多个线程进行垃圾回收</td>
<td style="text-align:left">老年代</td>
<td style="text-align:left">标记-整理算法</td>
<td style="text-align:left">替代串行的Serial Old GC</td>
</tr>
<tr>
<td style="text-align:center">G1</td>
<td style="text-align:left">并行</td>
<td style="text-align:left">用户线程和垃圾回收线程同时进行</td>
<td style="text-align:left">整堆</td>
<td style="text-align:left">分区算法</td>
<td style="text-align:left">在延迟可控的情况下尽可能提高吞吐量</td>
</tr>
<tr>
<td style="text-align:center">ZGC</td>
<td style="text-align:left">并行</td>
<td style="text-align:left">用户线程和垃圾回收线程同时进行</td>
<td style="text-align:left">整堆</td>
<td style="text-align:left">分区算法</td>
<td style="text-align:left">STW的时间不超过1ms，且不会随着堆的大小增加而增加</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>-XX:+PrintCommandLinelags，查看使用的垃圾收集器。</li>
<li>-XX:+UserSerialGC，制定使用Serial GC和Serial Old GC.</li>
<li>XX:+UseParNewGC，指定新生代使用ParNew GC，-XX:+UseConcMarkSweepGC，指定老年代使用CMS GC</li>
<li>-XX:+UseParallelGC，指定新生代使用Parallel GC， -XX:+UseParallelOldGC，指定老年代使用Parallel Old GC，这两个配置一个，另一个自动激活</li>
</ul>
<h3 id="Parellel-Gc-和-Parallel-Old-GC"><a href="#Parellel-Gc-和-Parallel-Old-GC" class="headerlink" title="Parellel Gc 和 Parallel Old GC"></a>Parellel Gc 和 Parallel Old GC</h3><p> <img src = "
/JAVA/
图片25.png
"><br>在一次垃圾收集过程中，会进行一次STW，并且会有多个线程同时进行垃圾回收。</p>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p> <img src = "
/JAVA/
图片26.png
" ><br>CMS整个垃圾收集过程更长，但是STW的时间变短，在垃圾收集过程中大部分时间用户线程还在执行，所以用户体验更好了，但是吞吐量变低。（单位时间内执行的拥护线程更短了）</p>
<ul>
<li>初始标记：<ul>
<li>STW，暂停所有工作线程</li>
<li>然后标记出GC Roots能直接可达的对象</li>
<li>一旦标记完，就回复工作线程继续执行</li>
<li>这个阶段比较短</li>
</ul>
</li>
<li>并发标记：<ul>
<li>从上一个阶段标记出的对象，开始遍历整个老年代，标记出所有的可达对象。</li>
<li>耗时会比较长</li>
<li>但是不需要STW，用户线程与垃圾收集线程一起执行</li>
<li>三色标记</li>
</ul>
</li>
<li>重新标记：<ul>
<li>上个阶段标记的对象，可能有误差，需要进行修正。</li>
<li>需要STW，但是时间也不是很长。</li>
<li>增量更新</li>
</ul>
</li>
<li><p>并发清除：</p>
<ul>
<li>删除垃圾对象</li>
<li>由于不需要移动对象，这个阶段也可以和用户线程也一起执行，不需要STW</li>
</ul>
</li>
<li><p>如果在并发标记、并发清理的过程中，由于用户线程同时执行，如果有新对象要进入老年代，但是空间又不够，就会导致“concurrent mode failure”，此时就需要Serial Old做一次垃圾收集，就会做一次全局的STW。</p>
</li>
<li><p>并发清理过程中，可能产生新的垃圾，这些就是“浮动垃圾”，只能等到下一次GC时来清理。</p>
</li>
<li><p>由于采用表情-清除，所以会出事内存碎片，可以让JVM在执行完后再做一次整理。也可以指定多少次GC后来做整理。默认时0，即每次GC都会整理。</p>
</li>
</ul>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p> <img src = "
/JAVA/
图片27.png
" ></p>
<p>把空间分为regin，每一个方块叫做regin，堆内存会分为2048个regin，每个regin的大小等于堆内存/2048。分成Eden，S0，S1，老年代区，只不过空间不是连续的。Humongous区是专门用来存放大对象的(如果一个对象大小超过了一个regin的50%,那么就是大对象)。<br> <img src = "
/JAVA/
图片28.png
"></p>
<ul>
<li>初始标记(同CMS)：<ul>
<li>STW，暂停所有工作线程</li>
<li>然后标记出GC Roots能直接可达的对象</li>
<li>一旦标记完，就回复工作线程继续执行</li>
<li>这个阶段比较短</li>
</ul>
</li>
<li>并发标记(同CMS)：<ul>
<li>从上一个阶段标记出的对象，开始遍历整个老年代，标记出所有的可达对象。</li>
<li>耗时会比较长</li>
<li>但是不需要STW，用户线程与垃圾收集线程一起执行</li>
<li>三色标记</li>
</ul>
</li>
<li>重新标记(同CMS)：<ul>
<li>上个阶段标记的对象，可能有误差，需要进行修正。</li>
<li>需要STW，但是时间也不是很长。</li>
<li>增量更新</li>
</ul>
</li>
<li><p>筛选回收(类CMS)：</p>
<ul>
<li>需要STW，来清除垃圾对象。</li>
<li>需要制定GC的STW停顿的时间，所以可能并不会回收掉所有垃圾对象，默认200ms。</li>
<li>采用复制算法，不会产生碎片。（会把某个region里的垃圾对象复制另外空间region区域，比如相邻的）</li>
</ul>
</li>
<li><p>Young GC：Ednen区满，就会触发G1的YoungGC，对Eden区进行GC</p>
</li>
<li>Mixed GC：老年代达到了指定的百分比，回收所有的新生代以及部分老年代，以及大对象区。</li>
<li>Full GC：在进行Mixed GC过程中，采用的复制算法，如果复制过程中内存不够，则会触发Full GC，会STW，并采用单线程进行标记-整理算法进行GC，相当于一次Serial GC。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JAVA/" rel="tag"># JAVA</a>
              <a href="/tags/JVM/" rel="tag"># JVM</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/04/24/%5BMySQL%5D%E5%9F%BA%E7%A1%80/" rel="prev" title="[MySQL]基础">
                  <i class="fa fa-chevron-left"></i> [MySQL]基础
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/09/15/%E6%B5%8B%E8%AF%95/" rel="next" title="测试">
                  测试 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81NTkwNy8zMjM3MQ=="></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ciallo～(∠・ω< )⌒☆​</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"mhchem":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script src="/js/third-party/comments/livere.js"></script>

</body>
</html>
